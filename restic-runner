#!/bin/bash

# restic-runner
# http://github.com/alphapapa/restic-runner

# * Instructions

# Repository config files should specify these variables:

# $RESTIC_REPOSITORY: Path to repository
# $RESTIC_PASSWORD_FILE: Path to password file

# Backup set config files should specify these variables:

# $tag: Tag string for backup set.
# TODO: Rename to include_paths
# $include_files: An array of strings, each of which is a path to backup.
# $exclude_patterns: An array of strings, each of which is an exclude glob pattern.
# $keep_policy: An array of "--keep-period N" strings (unquoted in the array)

# * Defaults

config_dir=~/.config/backup/restic

# * Functions

# ** Script functions

function debug {
    if [[ $debug ]]
    then
        function debug {
            echo "DEBUG: $@" >&2
        }
        debug "$@"
    else
        function debug {
            true
        }
    fi
}
function error {
    echo "ERROR: $@" >&2
    ((errors++))  # Initializes automatically
}
function die {
    error "$@"
    exit $errors
}
function usage {
    cat <<EOF
$0 [OPTIONS] ...?

This does something cool!

Options
  -d, --debug  Print debug info
  -h, --help   I need somebody!
EOF
}
function log {
    echo "LOG ($(date --rfc-3339=seconds)): $@"
}

# ** Helper functions

function expand_exclude_patterns {
    # If $exclude_patterns is non-empty, return a string of
    # "--exclude=PATTERN" for each pattern.

    if [[ ${exclude_patterns[@]} ]]
    then
        for pattern in "${exclude_patterns[@]}"
        do
            result="$result --exclude=$pattern"
        done
        echo "$result"
    else
        return 1  # Is this correct?
    fi
}

function repo_du {
    du -bs "$RESTIC_REPOSITORY" | awk '{print $1}'
}

function human_bytes {
    # Return bytes ($1) converted to MB, or GB with 3 decimal places,
    # as appropriate.
    local bytes=$1

    if [[ $bytes -ge $(( 1024 ** 3 )) ]]
    then
        local suffix=GB
        local expt=3
        local scale=3
    else
        local suffix=MB
        local expt=2
        local scale=0
    fi

    echo $(bc <<<"scale=$scale; $bytes / (1024^$expt)") $suffix
}

function human_duration {
    # Return human-friendly difference between timestamps ($1 and $2).
    # $2 should be the later timestamp.  Timestamps should be strings
    # in any form that GNU date accepts.

    local ts1=$(date +%s --date "$1")
    local ts2=$(date +%s --date "$2")
    local difference=$(( $ts2 - $ts1 ))

    local hours=$(bc <<<"$difference / 60 / 60")
    local minutes=$(bc <<<"$difference / 60 % 60")
    local seconds=$(bc <<<"$difference % 60")

    local time
    [[ $hours -gt 0 ]] && time="${hours}h"
    [[ $minutes -gt 0 ]] && time="${time}${minutes}m"
    [[ $seconds -gt 0 ]] && time="${time}${seconds}s"
    [[ $time ]] || time="0s"

    echo "$time"
}

# ** Commands

function backup {
    log "BACKING UP..."

    restic backup \
           --one-file-system \
           --exclude-caches \
           --exclude-if-present .nobackup \
           $(expand_exclude_patterns) \
           --tag "$tag" \
           "${include_files[@]}"
}
function check {
    log "CHECKING..."

    restic check
}
function forget {
    log "FORGETTING AND PRUNING..."

    restic forget \
           --tag "$tag" \
           --prune ${keep_policy[@]}
}
function init {
    log "INITIALIZING..."

    restic init
}

# * Args

args=$(getopt -n "$0" -o dh -l debug,repo:,set:,tag:,help -- "$@") || exit 1
eval set -- "$args"

while true
do
    case "$1" in
        -d|--debug)
            debug=true
            ;;
        -h|--help)
            usage
            exit
            ;;
        --repo)
            # Destination repo
            shift
            repo=$1
            ;;
        --set)
            # Backup set
            shift
            set=$1
            ;;
        --tag)
            # Backup tag
            shift
            tag=$1
            ;;
        --)
            # Remaining args
            shift
            commands=("$@")
            break
            ;;
    esac

    shift
done

debug "ARGS: $args"
debug "Commands: ${commands[@]}"

# ** Verify required arguments

[[ ${commands[@]} ]] || die "No command specified (one or more of: backup, check, forget)"

# The set isn't required for, e.g. check, and restic will give its own
# error if necessary, so we can skip these checks for now.

#  [[ $repo ]] || die "No repo specified"
#  [[ $set ]] || die "No backup set specified"

# * Include repo and set files

# The set isn't required for, e.g. check, and restic will give its own
# error if necessary, so we can skip these checks for now.

# MAYBE: If we change to a temporary, empty directory when sourcing
# these, it might help prevent shell glob expansion in case of
# unquoted patterns.

source $config_dir/repos/$repo # || die "Can't source repo file: $config_dir/repos/$repo"
source $config_dir/sets/$set # || die "Can't source set file: $config_dir/sets/$set"

# * Main

# Run command functions
for command in ${commands[@]}
do
    # Log before command
    du_before=$(repo_du)
    date_before=$(date)

    # Run command (backup, forget, prune, etc.)
    $command || die "$command failed."

    # Log after command
    du_after=$(repo_du)
    date_after=$(date)

    # Compute and log difference (converting bytes to MB or GB)
    du_difference_human=$(human_bytes $(( $du_after - $du_before )))
    du_after_human=$(human_bytes $du_after)
    if [[ $(($du_after - $du_before)) -gt -1 ]]
    then
        plus_minus="+"
    else
        plus_minus="-"
    fi

    duration=$(human_duration "$date_before" "$date_after")

    log "$command finished.  Duration: $duration  Repo size: $du_after_human (${plus_minus}${du_difference_human})"

done

# Exit with number of errors, which is perfect for chronic.
exit $errors
